<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-07-21 Mon 08:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>=ltlmix=</title>
<meta name="author" content="root" />
<meta name="description" content="Spot command-line tool for combining LTL formulas randomly" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="spot.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="tools.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title"><code>ltlmix</code></h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org82d80e3">Shape of the generated formulas</a>
<ul>
<li><a href="#org08f418b">Size of the syntax tree</a></li>
<li><a href="#org0d5347e">Operator priorities</a></li>
<li><a href="#org1264dd5">Boolean or LTL syntax tree</a></li>
</ul>
</li>
<li><a href="#orgb814f43">Randomizing atomic propositions with <code>-A</code> or <code>-P</code></a></li>
<li><a href="#org25f3f60">More serious examples</a>
<ul>
<li><a href="#orgef4f8f9">Mixing the DAC patterns</a></li>
<li><a href="#orgc5e3efd">Random conjunctions</a></li>
<li><a href="#org72f89bf">Random conjunctions for LTL synthesis</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="org242cb77" class="figure">
<p><object type="image/svg+xml" data="spot2.svg" class="org-svg" id="spotlogo">
Sorry, your browser does not support SVG.</object>
</p>
</div>
<p>
This tool creates new formulas by combining formulas randomly selected
from an input set of formulas.  Some authors have argued that for some
tasks, like <a href="https://www.cs.rice.edu/~vardi/papers/time13.pdf">LTL satisfiability</a>, working with randomly generated
formulas is often easy, because random formulas tend to simplify
trivially.  <code>ltlmix</code> allows you to take a set of formulas, usually
some handwritten, meaningful formulas, and combine those formulas to
build larger sets that are possibly more challenging.
</p>

<p>
Here is a very simple example that builds five formulas that are
Boolean combination of formulas taken from the set
\(\{\mathsf{GF}a,\mathsf{FG}b,\mathsf{X}c\}\):
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -f GFa -f FGb -f Xc -n 5
</pre>
</div>

<pre class="example">
!FGb xor !Xc
!GFa -&gt; !FGb
FGb | (FGb -&gt; Xc)
FGb
GFa &amp; (FGb | Xc)
</pre>
<div id="outline-container-org82d80e3" class="outline-2">
<h2 id="org82d80e3">Shape of the generated formulas</h2>
<div class="outline-text-2" id="text-org82d80e3">
</div>
<div id="outline-container-org08f418b" class="outline-3">
<h3 id="org08f418b">Size of the syntax tree</h3>
<div class="outline-text-3" id="text-org08f418b">
<p>
For each formula that it generates, <code>ltlmix</code> constructs a random
syntax-tree of a certain size (5 by default) in which internal nodes
represent operators selected randomly from a list of operators.
Leaves of that tree are subformulas selected randomly from the set of
input formulas.  As an example, the syntax tree of <code>!φ₁ xor !φ₂</code> has
size 5, and its leaves <code>φ₁</code> and <code>φ₂</code> will be taken randomly from the
set of input formulas.
</p>

<p>
The algorithm is actually the same as for <code>randltl</code>, except that
<code>randltl</code> uses random atomic propositions as leaves when <code>ltlmix</code> uses
random formulas.
</p>

<p>
The same input formula can be picked several times to be used on
multiple leaves of the tree.  Note that because Spot implements some
trivial rewritings directly during the construction of any formula,
formulas like <code>FGb | !!FGb</code> (which correspond to a tree of size 5 in
the above example) cannot be represented: they are automatically
simplified to <code>FGb</code>.  Similarly, something like <code>φ xor φ</code> will be
output as <code>0</code>.
</p>

<p>
The size of the tree can be changed using the <code>--tree-size</code> option.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-keyword">for</span> i<span class="org-keyword"> in</span> 1 2 3 4 5 6 7 8 9 10 11 12; <span class="org-keyword">do</span>
    ltlmix -fXa -fGb -fFc -fXd -fGe --tree-size=$<span class="org-variable-name">i</span>
<span class="org-keyword">done</span>
</pre>
</div>

<pre class="example" id="org9f803de">
Fc
!Xd
0
Ge xor !Fc
!Xd xor !Ge
!Xd xor (Fc | Xd)
!Ge
Ge xor (!Ge -&gt; Gb)
Ge xor (!Xa -&gt; !Fc)
(Ge &amp; !Fc) xor (!Gb xor !Ge)
(Ge &amp; !Fc) xor (!Gb xor (Gb | Fc))
(Ge &amp; (Gb xor Xd)) xor (!Fc -&gt; (Gb | Fc))
</pre>

<p>
The above shows that while the size of the syntax tree generally grows
along with <code>--tree-size</code> there are several cases where it reduces
trivially.
</p>
</div>
</div>
<div id="outline-container-org0d5347e" class="outline-3">
<h3 id="org0d5347e">Operator priorities</h3>
<div class="outline-text-3" id="text-org0d5347e">
<p>
It is possible to control the set of operators used in the generation.
The first step is to obtain that list of operators with <code>--dump-priorities</code>.
For instance:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fXa -fGb -fFc -fXd -fGe --dump-priorities
</pre>
</div>

<pre class="example" id="orga878b1d">
Use --boolean-priorities to set the following Boolean formula priorities:
sub	5
false	0
true	0
not	1
equiv	1
implies	1
xor	1
and	1
or	1
</pre>

<p>
In the above list, <code>false</code> and <code>true</code> represent the Boolean constants:
those are usually undesirable when building random Boolean formulas,
especially with Spot's trivial rewritings.  <code>sub</code> represents a random
formula drawn from the list of input formulas.
</p>

<p>
The above command shows that each operator has a weight, called
<i>priority</i>.  When the priority is 0, the operator is never used.  When
<code>ltlmix</code> generates a syntax tree of size N, it looks among all
operators that can be used at the root of such a tree, and performs a
weighted random selection.  In other words, an operator with priority
<code>2</code> will be twice more likely to be selected than an operator with
priority <code>1</code>.
</p>

<p>
Those priorities can be changed with <code>--boolean-priorities</code> as in the
following example, which disables <code>xor</code> and makes <code>&lt;-&gt;</code> thrice more
likely to appear.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span class="org-keyword">for</span> i<span class="org-keyword"> in</span> 1 2 3 4 5 6 7 8 9 10 11 12; <span class="org-keyword">do</span>
    ltlmix -fXa -fGb -fFc -fXd -fGe --tree-size=$<span class="org-variable-name">i</span> --boolean-prio=<span class="org-string">'xor=0,equiv=3'</span>
<span class="org-keyword">done</span>
</pre>
</div>

<pre class="example" id="orge0d6066">
Fc
!Xd
1
Ge &lt;-&gt; !Fc
!Xd &lt;-&gt; !Ge
!Xd &lt;-&gt; (Fc | Xd)
Ge
Ge &lt;-&gt; (Gb &lt;-&gt; !Ge)
Ge &lt;-&gt; (!Fc &lt;-&gt; !Xa)
(Ge &amp; !Fc) &lt;-&gt; (!Ge -&gt; !Gb)
(Ge &amp; !Fc) &lt;-&gt; ((Gb | Fc) -&gt; !Gb)
(Ge &amp; (Gb &lt;-&gt; Xd)) &lt;-&gt; ((Gb | Fc) &lt;-&gt; !Fc)
</pre>
</div>
</div>
<div id="outline-container-org1264dd5" class="outline-3">
<h3 id="org1264dd5">Boolean or LTL syntax tree</h3>
<div class="outline-text-3" id="text-org1264dd5">
<p>
By default, the syntax tree generated on top of the randomly selected
input formulas uses only Boolean operators.
</p>

<p>
Using option <code>-L</code> will use LTL operators instead.
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fXa -fGb -fFc --tree-size=10 -L -n10
</pre>
</div>

<pre class="example" id="orgded88c0">
Gb R (XFc W 0)
!(Gb | !Xa)
1 U !X(0)
(Xa xor Gb) -&gt; (GXa M Fc)
GFc M 1
(Fc U Gb) -&gt; (0 R Xa)
!Gb &lt;-&gt; (Gb | GFc)
1
GFc | (1 U Xa)
!(Xa | GFc)
</pre>

<p>
The following operators are used:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fXa -fGb -fFc -fXd -fGe -L --dump-priorities
</pre>
</div>

<pre class="example" id="org0ab8f61">
Use --ltl-priorities to set the following LTL priorities:
sub	5
false	1
true	1
not	1
F	1
G	1
X	1
strongX	0
equiv	1
implies	1
xor	1
R	1
U	1
W	1
M	1
and	1
or	1
</pre>

<p>
Note that in the LTL case, <code>false</code> and <code>true</code> can be generated by
default: when building leave, <code>alse</code> and <code>true</code> have the same
probability to be selected as any input formula.
</p>
</div>
</div>
</div>
<div id="outline-container-orgb814f43" class="outline-2">
<h2 id="orgb814f43">Randomizing atomic propositions with <code>-A</code> or <code>-P</code></h2>
<div class="outline-text-2" id="text-orgb814f43">
<p>
Options <code>-A</code> or <code>-P</code> can be used to change the atomic propositions
used in the input formulas.  This works as follows: if option <code>-A N</code>
was given, every time an input formula φ is selected, its atomic
propositions are replaced by atomic propositions randomly selected in
a set of size \(N\).  If φ uses \(i\) atomic propositions and \(i\ge N\),
then those \(i\) atomic propositions will be remapped to \(i\) distinct
atomic propositions chosen randomly in that set.  If \(i>N\), some of
the new atomic propositions may replace several of the original atomic
propositions.
</p>

<p>
Option <code>-P N</code> is similar to <code>-A N</code>, except that the selected atomic
propositions can possibly be negated.
</p>


<p>
These options solve two problems:
</p>

<ul class="org-ul">
<li>They lessen the issue that a formula selected several times can lead
to syntax tree such as <code>φ | φ | φ</code> that reduces to <code>φ</code>.  Now, each
occurrence of <code>φ</code> as a chance to use different atomic propositions.
The larger <code>N</code> is, the more likely it is that these copies of φ
will be different.</li>

<li>They allow combining formulas that had completely different sets of
atomic propositions, in such a way that they are now interdependent.
The smaller N is the more likely it is that subformulas will share
atomic propositions.</li>
</ul>


<p>
Here is that same example with a single formula, <code>GFa</code>, whose atomic
propositions will be randomly replaced by one of
\(\{p_0,p_1,p_2,p_3,p_4\}\).
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fGFa -A5 --tree-size=8 -n10
</pre>
</div>

<pre class="example" id="orgce5789b">
(GFp2 &amp; GFp3) xor (!GFp0 xor GFp1)
(GFp4 -&gt; GFp1) -&gt; !GFp2
!GFp4 | ((GFp2 &amp; GFp3) -&gt; GFp2)
!GFp2 | (GFp3 &lt;-&gt; (GFp2 &amp; GFp1))
!GFp0 | GFp4
!(GFp2 &amp; GFp1) &lt;-&gt; (GFp3 xor GFp0)
(GFp2 xor GFp0) | (GFp4 -&gt; !GFp0)
(GFp4 | !GFp3) -&gt; GFp4
!GFp0 -&gt; (GFp2 | GFp1)
!GFp1 &lt;-&gt; (!GFp2 xor !GFp1)
</pre>

<p>
Here is a similar example, with polarized atomic propositions instead:
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fGFa -P5 --tree-size=8 -n10
</pre>
</div>

<pre class="example" id="orgaff2d5a">
(GFp2 &amp; GF!p3) xor (GFp4 -&gt; !GF!p1)
(GFp4 | !GFp2) -&gt; (GFp1 -&gt; GF!p1)
!GF!p2 &amp; (GF!p0 xor (GF!p0 -&gt; GF!p3))
GFp1 &lt;-&gt; (GF!p3 | !GFp0)
GF!p1 &amp; GFp0 &amp; (GF!p3 xor !GF!p4)
(GF!p1 xor GF!p2) | (GF!p3 &amp; !GF!p4)
!(GFp4 xor (!GF!p2 | !GF!p3))
GFp0 | (!GFp1 -&gt; (GFp1 -&gt; GF!p4))
GF!p1 xor (!GF!p2 | (GF!p1 &lt;-&gt; GFp0))
!((GF!p2 &lt;-&gt; GF!p4) &amp; (GFp1 xor GF!p2))
</pre>
</div>
</div>
<div id="outline-container-org25f3f60" class="outline-2">
<h2 id="org25f3f60">More serious examples</h2>
<div class="outline-text-2" id="text-org25f3f60">
</div>
<div id="outline-container-orgef4f8f9" class="outline-3">
<h3 id="orgef4f8f9">Mixing the DAC patterns</h3>
<div class="outline-text-3" id="text-orgef4f8f9">
<p>
The command <a href="genltl.html"><code>genltl --dac-pattern</code></a> will print a list of 55 LTL
formulas representing various specification patterns listed by <a href="https://doi.org/10.1145/302405.30267">Dwyer
et al. (FMSP'98)</a>.  Using <code>--stat=%x</code> to count the atomic propositions
in each formula, and some standard unix tools, we can compute that
they use at most 6 atomic propositions.
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --dac-pattern --stat=%x | sort -n | tail -n 1
</pre>
</div>
<pre class="example">
6
</pre>


<p>
Based on this, we could decide to generate Boolean combination of
those formulas while replacing atomic propositions by literals built
out of a set of 10 atomic propositions (chosen larger than 6 to ensure
that each individual formula will still make sense after the change of
atomic propositions).
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --dac-pattern | ltlmix -n8 -P10
</pre>
</div>

<pre class="example">
!G((p8 &amp; F!p7) -&gt; (!p4 U (!p7 | (!p2 &amp; !p4 &amp; X(!p4 U p1))))) xor !G(!p3 -&gt; ((p4 &amp; !p7) U (!p4 | ((p4 &amp; p7) U (!p4 | ((p4 &amp; !p7) U (!p4 | ((p4 &amp; p7) U (!p4 | (!p7 W !p4) | Gp7)))))))))
!G(!p3 -&gt; Gp5) xor !G(!p7 -&gt; G(p9 -&gt; (!p5 &amp; !p8 &amp; X(!p5 U p2))))
G(p6 -&gt; ((!(!p1 &amp; p7 &amp; X(!p1 U (!p1 &amp; !p3))) U (p1 | !p2)) | G!(p7 &amp; XF!p3))) &amp; (G((!p4 &amp; XF!p5) -&gt; XF(!p5 &amp; F!p0)) &lt;-&gt; G((p5 &amp; !p6) -&gt; (p5 W (p5 &amp; p7))))
!G((p0 &amp; p9) -&gt; (!p7 W (!p0 | p4))) &amp; !G((p1 &amp; !p2) -&gt; (!p8 W p2))
((Fp2 -&gt; ((!p1 -&gt; (!p2 U (p0 &amp; !p2))) U p2)) -&gt; G(p1 -&gt; G(p9 -&gt; (!p4 &amp; p8 &amp; X(!p4 U !p7))))) xor G(p1 -&gt; Gp9)
!G((p5 &amp; !p9 &amp; F!p5) -&gt; ((!p8 -&gt; (p5 U (!p0 &amp; p5))) U !p5)) -&gt; !G((p6 &amp; p9) -&gt; (!p7 W !p9))
G((!p1 &amp; !p2) -&gt; (p9 W p1)) &lt;-&gt; (G(p5 -&gt; G(p0 -&gt; F!p4)) -&gt; (Fp6 -&gt; ((!p5 &amp; !p6) U (p6 | ((p5 &amp; !p6) U (p6 | ((!p5 &amp; !p6) U (p6 | ((p5 &amp; !p6) U (p6 | (!p5 U p6)))))))))))
((Fp1 -&gt; ((p6 -&gt; (!p1 U (!p1 &amp; !p2 &amp; X(!p1 U !p9)))) U p1)) &lt;-&gt; (F!p0 -&gt; (p0 U (p0 &amp; !p7 &amp; X(p0 U !p9))))) | (Fp2 -&gt; (p6 U (p2 | (p6 &amp; !p7 &amp; X(p6 U p1)))))
</pre>


<p>
Now we might want to clean this list a bit by relabeling each formula
so is uses atomic propositions \(\{p_0,p_1,...\}\) starting at 0 and without gap.
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --dac-pattern | ltlmix -n8 -P10 | ltlfilt --relabel=pnn
</pre>
</div>

<pre class="example">
!G((p0 &amp; F!p1) -&gt; (!p2 U (!p1 | (!p2 &amp; !p3 &amp; X(!p2 U p4))))) xor !G(!p5 -&gt; ((!p1 &amp; p2) U (!p2 | ((p1 &amp; p2) U (!p2 | ((!p1 &amp; p2) U (!p2 | ((p1 &amp; p2) U (!p2 | (!p1 W !p2) | Gp1)))))))))
!G(!p0 -&gt; Gp1) xor !G(!p2 -&gt; G(p3 -&gt; (!p1 &amp; !p4 &amp; X(!p1 U p5))))
G(p0 -&gt; ((!(!p1 &amp; p2 &amp; X(!p1 U (!p1 &amp; !p3))) U (p1 | !p4)) | G!(p2 &amp; XF!p3))) &amp; (G((!p5 &amp; XF!p6) -&gt; XF(!p6 &amp; F!p7)) &lt;-&gt; G((!p0 &amp; p6) -&gt; (p6 W (p2 &amp; p6))))
!G((p0 &amp; p1) -&gt; (!p2 W (!p0 | p3))) &amp; !G((p4 &amp; !p5) -&gt; (!p6 W p5))
((Fp0 -&gt; ((!p1 -&gt; (!p0 U (!p0 &amp; p2))) U p0)) -&gt; G(p1 -&gt; G(p3 -&gt; (!p4 &amp; p5 &amp; X(!p4 U !p6))))) xor G(p1 -&gt; Gp3)
!G((p0 &amp; !p1 &amp; F!p0) -&gt; ((!p2 -&gt; (p0 U (p0 &amp; !p3))) U !p0)) -&gt; !G((p1 &amp; p4) -&gt; (!p5 W !p1))
G((!p0 &amp; !p1) -&gt; (p2 W p0)) &lt;-&gt; (G(p3 -&gt; G(p4 -&gt; F!p5)) -&gt; (Fp6 -&gt; ((!p3 &amp; !p6) U (p6 | ((p3 &amp; !p6) U (p6 | ((!p3 &amp; !p6) U (p6 | ((p3 &amp; !p6) U (p6 | (!p3 U p6)))))))))))
((Fp0 -&gt; ((p1 -&gt; (!p0 U (!p0 &amp; !p2 &amp; X(!p0 U !p3)))) U p0)) &lt;-&gt; (F!p4 -&gt; (p4 U (p4 &amp; !p5 &amp; X(p4 U !p3))))) | (Fp2 -&gt; (p1 U (p2 | (p1 &amp; !p5 &amp; X(p1 U p0)))))
</pre>
</div>
</div>
<div id="outline-container-orgc5e3efd" class="outline-3">
<h3 id="orgc5e3efd">Random conjunctions</h3>
<div class="outline-text-3" id="text-orgc5e3efd">
<p>
Some benchmarks (e.g., <a href="https://www.cs.rice.edu/~vardi/papers/time13.pdf">for LTL satisfiability</a>) are built as
conjunctions of \(L\) random formulas picked from a set of basic
formulas.  Each picked formula has its atomic propositions mapped to
random literals built from a subset of \(m\) atomic variables.
</p>

<p>
Given a value for \(m\), option <code>-P m</code> will achieve the second part of
the above description.  To build a conjunction of \(L\) formulas, we
need to ask for a tree of size \(2L-1\) in which only the <code>and</code> operator
is allowed.
</p>

<p>
Here is an example with \(L=10\) (hence <code>--tree-size=19</code>) and \(m=50\).
The example uses a small set of three basic formulas
\(\{\mathsf{G}a,\mathsf{F}a,\mathsf{X}a\}\) for illustration, but in
practice you should replace these <code>-f</code> options by <code>-F FILENAME</code>
pointing to a file containing all the input formulas to select from.
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fGa -fFa -fXa -n10 -P50 <span class="org-sh-escaped-newline">\</span>
       --tree-size=19 --boolean-prio=<span class="org-variable-name">not</span>=0,<span class="org-variable-name">or</span>=0,<span class="org-variable-name">xor</span>=0,<span class="org-variable-name">equiv</span>=0,<span class="org-variable-name">implies</span>=0
</pre>
</div>

<pre class="example" id="org9b6c1a1">
Xp27 &amp; F!p21 &amp; G!p19 &amp; X!p26 &amp; Fp4 &amp; Gp43 &amp; Fp39 &amp; Fp7
G!p28 &amp; G!p30 &amp; X!p34 &amp; Fp21 &amp; Gp3 &amp; Fp6 &amp; F!p18 &amp; Xp5 &amp; Fp8 &amp; F!p12
X!p32 &amp; Xp9 &amp; Gp4 &amp; Xp48 &amp; F!p48 &amp; X!p6 &amp; Fp5 &amp; Xp20 &amp; Fp28 &amp; Fp26
G!p46 &amp; X!p14 &amp; Fp29 &amp; X!p36 &amp; Fp12 &amp; Xp47 &amp; Fp42 &amp; Gp14 &amp; Fp19
G!p28 &amp; Fp21 &amp; Fp36 &amp; F!p0 &amp; G!p14 &amp; Xp21 &amp; F!p28 &amp; G!p21 &amp; Gp21 &amp; Gp40
Gp3 &amp; F!p48 &amp; F!p28 &amp; Xp7 &amp; Gp8 &amp; Xp42 &amp; Gp0 &amp; Xp36 &amp; F!p2 &amp; G!p0
Xp36 &amp; Xp46 &amp; F!p31 &amp; Xp11 &amp; Xp26 &amp; G!p9 &amp; F!p36 &amp; X!p12 &amp; Fp15 &amp; Xp18
Xp9 &amp; X!p33 &amp; Fp44 &amp; X!p13 &amp; Gp37 &amp; Xp19 &amp; G!p43 &amp; F!p34 &amp; Gp36 &amp; Gp10
Xp27 &amp; Xp5 &amp; Fp28 &amp; Xp18 &amp; G!p13 &amp; Gp35 &amp; Gp38 &amp; G!p45 &amp; G!p48 &amp; Gp12
Xp7 &amp; G!p48 &amp; Xp14 &amp; Fp24 &amp; Xp43 &amp; Fp47 &amp; Fp14 &amp; Gp30 &amp; Xp23 &amp; G!p31
</pre>

<p>
Random conjunctions is common enough to have its own flag.  Using <code>-C
N</code> will see the tree size to \(2N-1\) and disable all operators but
<code>and</code>.  The above command can therefore be reduced to
</p>

<div class="org-src-container">
<pre class="src src-sh">ltlmix -fGa -fFa -fXa -n10 -P50 -C10
</pre>
</div>

<pre class="example" id="org71cce97">
Xp27 &amp; F!p21 &amp; G!p19 &amp; X!p26 &amp; Fp4 &amp; Gp43 &amp; Fp39 &amp; Fp7
G!p28 &amp; G!p30 &amp; X!p34 &amp; Fp21 &amp; Gp3 &amp; Fp6 &amp; F!p18 &amp; Xp5 &amp; Fp8 &amp; F!p12
X!p32 &amp; Xp9 &amp; Gp4 &amp; Xp48 &amp; F!p48 &amp; X!p6 &amp; Fp5 &amp; Xp20 &amp; Fp28 &amp; Fp26
G!p46 &amp; X!p14 &amp; Fp29 &amp; X!p36 &amp; Fp12 &amp; Xp47 &amp; Fp42 &amp; Gp14 &amp; Fp19
G!p28 &amp; Fp21 &amp; Fp36 &amp; F!p0 &amp; G!p14 &amp; Xp21 &amp; F!p28 &amp; G!p21 &amp; Gp21 &amp; Gp40
Gp3 &amp; F!p48 &amp; F!p28 &amp; Xp7 &amp; Gp8 &amp; Xp42 &amp; Gp0 &amp; Xp36 &amp; F!p2 &amp; G!p0
Xp36 &amp; Xp46 &amp; F!p31 &amp; Xp11 &amp; Xp26 &amp; G!p9 &amp; F!p36 &amp; X!p12 &amp; Fp15 &amp; Xp18
Xp9 &amp; X!p33 &amp; Fp44 &amp; X!p13 &amp; Gp37 &amp; Xp19 &amp; G!p43 &amp; F!p34 &amp; Gp36 &amp; Gp10
Xp27 &amp; Xp5 &amp; Fp28 &amp; Xp18 &amp; G!p13 &amp; Gp35 &amp; Gp38 &amp; G!p45 &amp; G!p48 &amp; Gp12
Xp7 &amp; G!p48 &amp; Xp14 &amp; Fp24 &amp; Xp43 &amp; Fp47 &amp; Fp14 &amp; Gp30 &amp; Xp23 &amp; G!p31
</pre>

<p>
Selecting 10 random conjuncts out of 3×50×2=300 possibilities has a
13.7% chance that at least 2 conjuncts will be identical (see <a href="https://en.wikipedia.org/wiki/Birthday_problem">Birthday
paradox</a>), so because of Spot's trivial rewritings, some of the above
formulas may have fewer than 10 conjuncts.
</p>
</div>
</div>
<div id="outline-container-org72f89bf" class="outline-3">
<h3 id="org72f89bf">Random conjunctions for LTL synthesis</h3>
<div class="outline-text-3" id="text-org72f89bf">
<p>
Generating formulas for LTL synthesis differs from LTL satisfiability
because we have to deal with two sets of atomic proposition: one set
for input, and one set for output.
</p>

<p>
<a href="https://www.ijcai.org/proceedings/2017/0189.pdf">Zhu et al. (IJCAI'17)</a> generate their benchmark for LTL synthesis using
a setup similar to the above, except that when atomic propositions are
randomized, we must make sure not to change their input or output
nature.
</p>

<p>
They use small examples from the <a href="http://www.ist.tugraz.at/staff/jobstmann/lily/">Lily</a> distribution as basic formulas
to combine.  Spot can print those formulas using <code>genltl --lily</code>.
There are 23 of them, but we will limit ourselves to four of them for
illustrative purpose.
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --lily=8..11
</pre>
</div>

<pre class="example">
GFi0 -&gt; GFo0
GFi0 -&gt; (!o0 &amp; G(!o0 -&gt; ((!o0 U i0) &amp; (i0 -&gt; Fo0))) &amp; GFo0)
(GFi1 | Fi0) -&gt; (GFo1 | Go0)
!(G(i1 -&gt; Fo0) &amp; G(i0 -&gt; Fo1))
</pre>


<p>
Notice how these atomic propositions either start with <code>i</code> (for input)
or <code>o</code> for output.  This allows Spot to infer their nature.  For
instance, we could feed those directly to <a href="ltlsynt.html"><code>ltlsynt</code></a> to decide if they
are realizable:
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --lily=8..11 | ltlsynt --realizability
</pre>
</div>

<pre class="example">
REALIZABLE
REALIZABLE
REALIZABLE
UNREALIZABLE
</pre>


<p>
When randomizing the atomic propositions in these formulas before
combining them, we want to replace each input (resp. output)
proposition by a random input (resp. output) proposition.  This is
achieved by passing two numbers to <code>-A</code> or <code>-P</code>.  In the case of <a href="https://www.ijcai.org/proceedings/2017/0189.pdf">Zhu
et al.</a>, they do not change the polarity of the propositions during
their generation, so we would use <code>-A</code> to mimic their setup.
</p>

<p>
Here are 6 random conjunctions of the above four patterns, in which
each input (resp. output) atomic proposition has been replaced by a
random input (resp. output) atomic proposition picked randomly in a
set of 5 (resp. 4).
</p>


<div class="org-src-container">
<pre class="src src-sh">genltl --lily=8..11 | ltlmix -A5,4 -C3 -n6
</pre>
</div>

<pre class="example">
!(G(i3 -&gt; Fo3) &amp; G(i2 -&gt; Fo2)) &amp; (GFi2 -&gt; (!o1 &amp; GFo1 &amp; G(!o1 -&gt; ((!o1 U i2) &amp; (i2 -&gt; Fo1))))) &amp; (GFi4 -&gt; GFo1)
(GFi2 -&gt; (!o1 &amp; GFo1 &amp; G(!o1 -&gt; ((!o1 U i2) &amp; (i2 -&gt; Fo1))))) &amp; !(G(i0 -&gt; Fo1) &amp; G(i4 -&gt; Fo3)) &amp; (GFi4 -&gt; (!o3 &amp; GFo3 &amp; G(!o3 -&gt; ((i4 -&gt; Fo3) &amp; (!o3 U i4)))))
(GFi3 -&gt; (!o3 &amp; GFo3 &amp; G(!o3 -&gt; ((i3 -&gt; Fo3) &amp; (!o3 U i3))))) &amp; ((GFi2 | Fi3) -&gt; (GFo0 | Go2)) &amp; ((Fi0 | GFi2) -&gt; (GFo3 | Go2))
(GFi3 -&gt; GFo2) &amp; (GFi2 -&gt; GFo0) &amp; (GFi3 -&gt; (!o0 &amp; GFo0 &amp; G(!o0 -&gt; ((!o0 U i3) &amp; (i3 -&gt; Fo0)))))
!(G(i3 -&gt; Fo1) &amp; G(i1 -&gt; Fo3)) &amp; !(G(i3 -&gt; Fo0) &amp; G(i0 -&gt; Fo2)) &amp; ((GFi0 | Fi3) -&gt; (GFo0 | Go1))
((Fi1 | GFi4) -&gt; (Go0 | GFo2)) &amp; !(G(i0 -&gt; Fo2) &amp; G(i4 -&gt; Fo1)) &amp; !(G(i3 -&gt; Fo2) &amp; G(i1 -&gt; Fo1))
</pre>


<div class="org-src-container">
<pre class="src src-sh">genltl --lily=8..11 | ltlmix -A5,4 -C3 -n6 | ltlsynt --realizability
</pre>
</div>

<pre class="example">
UNREALIZABLE
UNREALIZABLE
REALIZABLE
UNREALIZABLE
UNREALIZABLE
UNREALIZABLE
</pre>


<p>
Note that because one of the original pattern is unrealizable, any
conjunction involving it will be unrealizable.  Even if we had only
realizable specifications to combine, the smaller the atomic
proposition sets are, the more likely the random conjuncts will be in
conflict.  Therefore, increasing the number of atomic propositions to
chose from may help to get more realizable formulas.
</p>

<div class="org-src-container">
<pre class="src src-sh">genltl --lily=8..11 | ltlmix -A50,50 -C3 -n6 | ltlsynt --realizability
</pre>
</div>

<pre class="example">
UNREALIZABLE
UNREALIZABLE
REALIZABLE
REALIZABLE
UNREALIZABLE
UNREALIZABLE
</pre>



<p>
When the original LTL synthesis specification formulas have atomic
propositions that do not start with <code>i</code> or <code>o</code>, options <code>--ins</code>,
<code>--outs</code>, or <code>--part-file</code> can be used to specify the nature of these
atomic propositions.  These options work as <a href="ltlsynt.html#input-options"><code>ltlsynt</code>'s input options</a>.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
