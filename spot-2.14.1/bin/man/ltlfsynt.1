.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.
.\" -*- coding: utf-8 -*-
.TH LTLFSYNT "1" "July 2025" "ltlfsynt (spot) 2.14.1" "User Commands"
.SH NAME
ltlfsynt \- check realizability of LTLf formulas
.SH SYNOPSIS
.B ltlfsynt
[\fI\,OPTION\/\fR...] [\fI\,FORMULA\/\fR...]
.SH DESCRIPTION
Convert LTLf formulas to transition\-based deterministic finite automata.
.PP
If multiple formulas are supplied, several automata will be output.
.SS "Input options:"
.TP
\fB\-f\fR, \fB\-\-formula\fR=\fI\,STRING\/\fR
process the formula STRING
.TP
\fB\-F\fR, \fB\-\-file\fR=\fI\,FILENAME\/\fR[\fI\,/COL\/\fR]\fI\,\/\fR
process each line of FILENAME as a formula; if COL
is a positive integer, assume a CSV file and read
column COL; use a negative COL to drop the first
line of the CSV file
.TP
\fB\-\-ins\fR=\fI\,PROPS\/\fR
comma\-separated list of uncontrollable (a.k.a.
input) atomic propositions, interpreted as a regex
if enclosed in slashes
.TP
\fB\-\-lbt\-input\fR
read all formulas using LBT's prefix syntax
.TP
\fB\-\-lenient\fR
parenthesized blocks that cannot be parsed as
subformulas are considered as atomic properties
.TP
\fB\-\-outs\fR=\fI\,PROPS\/\fR
comma\-separated list of controllable (a.k.a.
output) atomic propositions, , interpreted as a
regex if enclosed in slashes
.TP
\fB\-\-part\-file\fR=\fI\,FILENAME\/\fR
read the I/O partition of atomic propositions from
FILENAME
.TP
\fB\-\-semantics\fR=\fI\,Moore\/\fR|\fI\,Mealy\/\fR
Whether to work under Mealy (input\-first) or
Mealy (output\-first) semantics.  The default is
Mealy.
.TP
\fB\-\-tlsf\fR=\fI\,FILENAME\/\fR[\fI\,/VAR=VAL\/\fR[\fI\,\/\fR,VAR=VAL...]]
Read a TLSF specification from FILENAME, and call
syfco to convert it into LTLf.  Any parameter
assignment specified after a slash is passed as
\&'\-op VAR=VAL' to syfco.
.SS "Fine tuning:"
.TP
\fB\-\-backprop\fR=\fI\,nodes\/\fR|\fI\,states\/\fR|\fI\,trival\-states\/\fR
whether backpropagation should be done at the node
or state level (nodes by default)
.TP
\fB\-\-composition\fR=\fI\,size\/\fR|\fI\,ap\/\fR
If the translation is set to "compositional" this
option specify how to order n\-ary compositions: by
increasing size, or trying to group operands based
on their APs (the default).
.TP
\fB\-\-decompose\fR=\fI\,yes\/\fR|\fI\,no\/\fR
whether to decompose the specification as multiple
output\-disjoint problems to solve independently
(enabled by default)
.TP
\fB\-\-global\-equivalence\fR=\fI\,yes\/\fR|\fI\,no\/\fR|\fI\,before\-decompose\/\fR
whether to remove atomic propositions that are
always equivalent to another one (enabled by
default, both before and after decomposition)
.TP
\fB\-\-minimize\fR=\fI\,yes\/\fR|\fI\,no\/\fR
Minimize the automaton (disabled by default except
for the compositional translation). Has no effect
on on\-the\-fly translations.
.TP
\fB\-\-one\-step\-preprocess\fR=\fI\,yes\/\fR|\fI\,no\/\fR
attempt check one\-step realizability or
unrealizability of each state during on\-the\-fly or
restricted translations (enabled by default)
.TP
\fB\-\-polarity\fR=\fI\,yes\/\fR|\fI\,no\/\fR|\fI\,before\-decompose\/\fR
whether to remove atomic propositions that always
have the same polarity in the formula to speed
things up (enabled by default, both before and
after decomposition)
.TP
\fB\-\-simplify\-formula\fR=\fI\,yes\/\fR|\fI\,no\/\fR
simplify the LTLf formula with cheap
rewriting rules (enabled by default)
.TP
\fB\-\-translation\fR=\fI\,full\/\fR|\fI\,compositional\/\fR|\fI\,retricted\/\fR|\fI\,bfs\-on\-the\-fly\/\fR|\fI\,dfs\-on\-the\-fly\/\fR|\fI\,dfs\-strict\-on\-the\-fly\/\fR
The type of translation to use: (full) is a direct
translation to MTDFA, (compositional) breaks the
specification on Boolean operators and  builds the
MTDFA by compositing minimized subautomata,
(restrict) is a direct translation but that is
restricted to the only part useful to synthesis,
(dfs\-on\-the\-fly) is the on\-the\-fly version of
"restrict" that follow a dfs order that stop on
previously seen BDD nodes, solving the game as the
automaton is generated, (dfs\-strict\-on\-the\-fly)
stops on visited states, (bfs\-on\-the\-fly) same as
dfs\-on\-the\-fly but using bfs order.  The default
is bfs\-on\-the\-fly.
.SS "Output options:"
.TP
\fB\-\-aiger\fR[=\fI\,ite\/\fR|\:\fI\,isop\/\fR|\:\fI\,both[+ud][+dc][+sub0\/\fR|\:\fI\,sub1\/\fR|\:\fI\,sub2]\/\fR]
encode the winning strategy as an AIG circuit and
print it in AIGER format. The first word indicates
the encoding to used: "ite" for If\-Then\-Else
normal form; "isop" for irreducible sum of
products; "both" tries both and keeps the smaller
one. Other options further refine the encoding,
see aiger::encode_bdd. Defaults to "ite".
.TP
\fB\-d\fR, \fB\-\-dot\fR[\fI\,\/\fR=\fI\,game\/\fR|\fI\,strategy\/\fR:OPT|aig:OPT]
Use dot format when printing the result (game,
strategy, or AIG circuit).  The options that may
be used as OPT depend on the nature of what is
printed. For strategy, standard automata rendering
options are supported (e.g., see ltl2tgba \fB\-\-dot\fR).
For AIG circuit, use (h) for horizontal and (v)
for vertical layouts.
.TP
\fB\-\-hide\-status\fR
Hide the REALIZABLE or UNREALIZABLE line.  (Hint:
exit status is enough of an indication.)
.TP
\fB\-H\fR, \fB\-\-hoaf\fR[=\fI\,1.1\/\fR|\:\fI\,b\/\fR|\:\fI\,i\/\fR|\:\fI\,k\/\fR|\:\fI\,l\/\fR|\:\fI\,m\/\fR|\:\fI\,s\/\fR|\:\fI\,t\/\fR|\:\fI\,v\/\fR]
Output the automaton in HOA format (default).  Add
letters to select (1.1) version 1.1 of the format,
(b) create an alias basis if >=2 AP are used, (i)
use implicit labels for complete deterministic
automata, (s) prefer state\-based acceptance when
possible [default], (t) force transition\-based
acceptance, (m) mix state and transition\-based
acceptance, (k) use state labels when possible,
(l) single\-line output, (v) verbose properties
.TP
\fB\-q\fR, \fB\-\-quiet\fR
suppress all normal output
.TP
\fB\-\-realizability\fR
realizability only, do not compute a winning
strategy
.SS "Miscellaneous options:"
.TP
\fB\-\-help\fR
print this help
.TP
\fB\-\-verbose\fR
verbose mode
.TP
\fB\-\-version\fR
print program version
.PP
Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.
.SH BIBLIOGRAPHY
The following paper describes how LTLf synthesis using MTDFA works in ltlfsynt.

.TP
\(bu
Alexandre Duret-Lutz, Shufang Zhu, Nir Piterman, Giuseppe De Giacomo,
and Moshe Y. Vardi: Engineering an LTLf Synthesis Tool. Proceedings
of CIAA'25. To appear.
.SH "REPORTING BUGS"
Report bugs to <spot@lrde.epita.fr>.
.SH COPYRIGHT
Copyright \(co 2025 by the Spot authors, see the AUTHORS File for details.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
.br
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
.SH "SEE ALSO"
.BR ltlf2dfa (1)
.BR ltlsynt (1)
