#! /bin/sh
# -*- coding: utf-8 -*-
# Copyright (C) by the Spot authors, see the AUTHORS file for details.
#
# This file is part of Spot, a model checking library.
#
# Spot is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Spot is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

. ./defs || exit 1

cat >formulas.ltlf <<EOF
Gi0
Gi0&Fo0
Gi0&Fo0&Fi1
Gi0&Fo0&Fi1&Fo1&Fi2&Fi3&Fo2&Fi4
Gi0&Fo0&Fi1&Fo1&Fi2&Fi3&Fo2&Fi4&Fo3
i0
i0 U o0
i0 U(i1 U o0)
i0 U(i1 U(o0 U o1))
i0 U(i1 U(i2 U(i3 U(o0 U(o1 U o2)))))
(GFi1->GFo1)&(GFi2->GFo0)&(GFi0->GFo2)
G(o1->X[!]!o1)&G(o0->X[!]!o0)&G(o2->X[!]!o2)
G(i1->Fo1)&G(o1<->X!o1)&G(i2->Fo2)&G(o2<->X!o2)
(GFi3->GFo1)&(GFi1->GFo0)&(GFi2->GFo2)&(GFi0->GFo3)
G(o2->X[!]!o2)&G(o3->X[!]!o3)&G(o1->X[!]!o1)&G(o0->X[!]!o0)
G(i0->X[!](!o0 U i1))&G(i4->X[!](!o1 U i3))&G(i2->X[!](!o0 U i5))
G(i0->X[!](!o1 U i1))&G(i4->X[!](!o2 U i3))&G(i2->X[!](!o0 U o0))
G(i0|!X[!]o1)&G(i1|!X[!]o2)&G(i2|!X[!]o3)&((GFi3|Fi4)->(GFo4|Go0))
G(i0|!X[!]o1)&G(i1|!X[!]o2)&G(i2|!X[!]o3)&G(i3|!X[!]o4)&G(i4|!X[!]o0)
!(G(i3->Fo3)&G(i5->Fo2))&!(G(i0->Fo1)&G(i1->Fo0))&!(G(i4->Fo4)&G(i2->Fo4))
G(o1->X[!]!o1)&(Gi0->Fo2)&(G!i0->F!o2)&G(i1|!X[!]o3)&G(i2|!X[!]o4)&G(o->X[!]!o)
G(i1->X[!](o0 U i4))&G(i0->X(o3 U i3))&G(i5->X[!](o1 U i6))&G(i7->X[!](o2 U i2))
G(o<->i)
!i0 xor o0
FG(i0 W(i1<->Fo0))
Fo0 xor((o0<->Fi0)->Fi0)
(F!o1 U!XFo0)R(i0<->o0)
G(o1&((Xo0 xor(Fo0 xor F!G!i0))<->X(!o0|o1|Go0)))
(!o0 xor((Go0 M!(Xi1&Fo1))U Xi0))<->((i2 U i0)W 0)
!((Gi1 M(!i1 R o0))M!(o1 M 1))M(o2 xor G(i0 U i1))
FG((X!o2 M Fi0)M Fi0)xor(Fi1<->(o0 xor(o1|o2|Xo1)))
FG((FG(G!o0 R o1)R((i0 W i1)<->G!Fi1))<->(o0 W Go2))
(XX(0)M(F(Xi0 W(i0 W o0))xor(i1 U o0)))<->(!i1 M i2)
F((o0<->(i0<->i1))<->((i2&Fo0&Go2)W((!i2->i0)->X!o1)))
(i0<->o1)|((0 R((o2 M i2)U i0))R((!o2&Go0)R(Xo1 M!Xi1)))
!(X((i0 xor o1)|((o0 xor!o1)U i1))&(FXo0 R(o0 R!(i1 M 1))))
(o0<->(i2->i0))->((!i2&Fi2)M(Gi2 xor(!i1 M((i1 W o1)M(i0|o1)))))
EOF
genltl --tv-counter-mealy=2..3 \
       --tv-double-counters-mealy=2..3 \
       --tv-nim-mealy=2..3,1..3 \
       --chomp-mealy=2..3,2..3 >> formulas.ltlf

# Two formula based on ScutellÃ 's counterexample.
# They should be both realizable in any semantics.
f1="o0&G((o1->!o0)&(o0|o1|o2|o3|o4)&(o2->(!o0&!o1))&(o3->(!o0&!o1&!o2))"
f2="&(o4->(!o0&!o1&!o2&!o3))&(o1->Xo2)&(o3->Xo1)"
f3="&(o2->((!o&Xo3)|(o&Xo4)))&(o0->((i&Xo3)|(!i&Xo1))))&Fo4"
f3b="&(o2->((o&Xo3)|(!o&Xo4)))&(o0->((!i&Xo3)|(i&Xo1))))&Fo4"
echo "$f1$f2$f3" >> formulas.ltlf
echo "$f1$f2$f3b" >> formulas.ltlf
# Two formulas from issue #610:
echo 'X[!]X[!]X(0) && X[!]X(0)' >> formulas.ltlf
echo 'o1 & G(o1 xor X[!]o1) & o2 & G(o2 xor Xo2)' >> formulas.ltlf


cat >expected <<EOF
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
UNREALIZABLE UNREALIZABLE
REALIZABLE REALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
REALIZABLE REALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
UNREALIZABLE REALIZABLE
REALIZABLE REALIZABLE
REALIZABLE REALIZABLE
UNREALIZABLE UNREALIZABLE
UNREALIZABLE UNREALIZABLE
EOF
cut -f1 -d' ' <expected >expected.Moore
cut -f2 -d' ' <expected >expected.Mealy

for sem in Moore Mealy; do
  for sim in yes no; do
  for dec in yes no; do
  for tra in restr full comp dfs bfs dfs-strict; do
    bpvalues="states nodes trival"
    osvalues="yes no";
    case $tra in
        bfs | dfs | dfs-strict) bpvalues=nodes;;
        restr | full | comp) osvalues=no;;
    esac
    for min in yes no; do
    for pol in yes no; do
    for geq in $pol; do # simplified from "yes no" to reduce runtime
    for bp in $bpvalues; do
    for os in $osvalues; do
        ltlfsynt -F formulas.ltlf --decomp=$dec --trans=$tra --min=$min \
                 --semantics=$sem --global-equiv=$geq \
                 --polarity=$pol --backprop=$bp --one-step=$os \
                 --realizability --simplify=$sim >results
        test $? -le 1 || exit 2
        diff expected.$sem results || exit 2
    done
    done
    done
    done
    done
  done
  done
  done
done
